/**
 * Letter allowance and eligibility checking service
 * Extracts complex business logic for cleaner API routes
 */

import { createClient } from '@/lib/supabase/server'
import type { LetterAllowance } from '@/lib/types/letter.types'

/**
 * Result of checking if a user can generate a letter
 */
export interface GenerationEligibility {
  canGenerate: boolean
  isFreeTrial: boolean
  hasAllowance: boolean
  remainingAllowance: number | null
  totalGenerated: number
  reason?: string
}

/**
 * Check letter allowance from database
 */
export async function checkLetterAllowance(userId: string): Promise<LetterAllowance> {
  const supabase = await createClient()

  const { data } = await supabase.rpc('check_letter_allowance', {
    u_id: userId,
  })

  return {
    has_allowance: data?.has_access ?? false,
    remaining: data?.letters_remaining ?? 0,
  }
}

/**
 * Get total letters generated by user
 */
export async function getTotalLettersGenerated(userId: string): Promise<number> {
  const supabase = await createClient()

  const { data } = await supabase
    .from('profiles')
    .select('total_letters_generated')
    .eq('id', userId)
    .single()

  return data?.total_letters_generated || 0
}

/**
 * Check if user is eligible for free trial (first letter)
 */
export function isFreeTrialEligible(
  totalGenerated: number,
  hasAllowance: boolean
): boolean {
  return totalGenerated === 0 && !hasAllowance
}

/**
 * Comprehensive check for letter generation eligibility
 * Combines free trial and allowance checks
 */
export async function checkGenerationEligibility(
  userId: string
): Promise<GenerationEligibility> {
  // Run checks in parallel for performance
  const [totalGenerated, allowance] = await Promise.all([
    getTotalLettersGenerated(userId),
    checkLetterAllowance(userId),
  ])

  const hasAllowance = allowance.has_allowance
  const remainingAllowance = allowance.remaining

  // Determine if free trial applies
  const isFreeTrial = isFreeTrialEligible(totalGenerated, hasAllowance)

  // Check if user can generate
  const canGenerate = isFreeTrial || hasAllowance

  // Provide reason if not eligible
  let reason: string | undefined
  if (!canGenerate) {
    if (totalGenerated === 0) {
      reason = 'No letter allowance available. Please upgrade your plan.'
    } else {
      reason = 'No letter credits remaining. Please upgrade your plan.'
    }
  }

  return {
    canGenerate,
    isFreeTrial,
    hasAllowance,
    remainingAllowance,
    totalGenerated,
    reason,
  }
}
    totalGenerated,
    reason,
  }
}

/**
 * Deduct letter allowance with proper error handling
 * Returns true if deduction was successful
 */
export async function deductLetterAllowance(userId: string): Promise<{
  success: boolean
  wasDeducted: boolean
  error?: string
}> {
  const supabase = await createClient()

  const { data, error } = await supabase.rpc('deduct_letter_allowance', {
    u_id: userId,
  })

  if (error) {
    return {
      success: false,
      wasDeducted: false,
      error: error.message,
    }
  }

  return {
    success: true,
    wasDeducted: data ?? false,
    error: !data ? 'No letter allowances remaining (or race condition prevented overage)' : undefined,
  }
}

/**
 * Refund letter allowance (e.g., after failed generation)
 */
export async function refundLetterAllowance(
  userId: string,
  amount: number = 1
): Promise<{ success: boolean; error?: string }> {
  const supabase = await createClient()

  const { error } = await supabase.rpc('add_letter_allowances', {
    u_id: userId,
    amount,
  })

  if (!error) {
    return { success: true }
  }

  console.warn('[Allowance] add_letter_allowances RPC failed, falling back to manual refund:', error.message)

  const { data: subscription, error: subscriptionError } = await supabase
    .from('subscriptions')
    .select('id, credits_remaining, remaining_letters')
    .eq('user_id', userId)
    .eq('status', 'active')
    .order('created_at', { ascending: false })
    .limit(1)
    .maybeSingle()

  if (subscriptionError || !subscription) {
    return {
      success: false,
      error: subscriptionError?.message || 'No active subscription found for refund',
    }
  }

  const { error: updateError } = await supabase
    .from('subscriptions')
    .update({
      credits_remaining: (subscription.credits_remaining || 0) + amount,
      remaining_letters: (subscription.remaining_letters || 0) + amount,
      updated_at: new Date().toISOString(),
    })
    .eq('id', subscription.id)

  if (updateError) {
    return {
      success: false,
      error: updateError.message,
    }
  }

  return { success: true }
}

/**
 * Increment total letters generated counter
 */
export async function incrementTotalLetters(userId: string): Promise<{ success: boolean; error?: string }> {
  const supabase = await createClient()

  const { error } = await supabase.rpc('increment_total_letters', {
    p_user_id: userId,
  })

  if (error) {
    return {
      success: false,
      error: error.message,
    }
  }

  return { success: true }
}

/**
 * Check if deduction should be skipped based on user type
 */
export function shouldSkipDeduction(eligibility: GenerationEligibility): boolean {
  return eligibility.isFreeTrial
}

/**
 * Eligibility check result for API responses
 */
export interface EligibilityCheckResult {
  eligible: boolean
  needsSubscription: boolean
  error?: string
}

/**
 * Quick API-friendly eligibility check
 */
export async function checkApiEligibility(userId: string): Promise<EligibilityCheckResult> {
  const eligibility = await checkGenerationEligibility(userId)

  if (!eligibility.canGenerate) {
    return {
      eligible: false,
      needsSubscription: true,
      error: eligibility.reason || 'No letter credits remaining',
    }
  }

  return {
    eligible: true,
    needsSubscription: false,
  }
}
